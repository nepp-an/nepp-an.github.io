<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on nepp&#39;s blog</title>
    <link>https://nepp-an.github.io/post/</link>
    <description>Recent content in Posts on nepp&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 17 Jul 2021 15:12:44 +0800</lastBuildDate>
    
	<atom:link href="https://nepp-an.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>gopool</title>
      <link>https://nepp-an.github.io/post/gopool/</link>
      <pubDate>Sat, 17 Jul 2021 15:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/gopool/</guid>
      <description>gopool-头条使用的协程池 原生goroutine使用很方便 1 2 3 go func() { // do something } 但是原生goroutine存在一些问题，包括无法限制使用的goroutine总数。 单个goroutine使用的内存虽然很少2KB，但是大量的goroutine并发可能会导致OOM，所以协程池的使用还</description>
    </item>
    
    <item>
      <title>golang的内存模型</title>
      <link>https://nepp-an.github.io/post/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 14 Jul 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>memory model https://golang.org/ref/mem heppens-before的概念 内存重排 为了读写内存的效率，会对读写指令进行重新排列，这是cpu重排。 还有编译器重排： x = 0 for i in range(100): x = 1 fmt.Println(x) 编译器优化后 x = 1 for i in range(100): fmt.Println(x) 但是一旦x被别的goroutine修改，就会无法出现预期的结果。 CPU为了抚平内核、内存和硬盘之间的读写</description>
    </item>
    
    <item>
      <title>epoll</title>
      <link>https://nepp-an.github.io/post/epoll/</link>
      <pubDate>Sun, 11 Jul 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/epoll/</guid>
      <description>epoll epoll是一种I/O事件通知机制，是linux内核实现IO多路复用的一种方式。select和poll属于轮询机制。 假设有大量的请求和一个进程保持着TCP连接，但是其中只有一小部分是活跃的，这需要监听这些连接，在需要的时候返回，从而对其进行读写操作。 https://www.jianshu.com/p/31cdfd6f5a48</description>
    </item>
    
    <item>
      <title>runtime</title>
      <link>https://nepp-an.github.io/post/runtime/</link>
      <pubDate>Sun, 11 Jul 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/runtime/</guid>
      <description>goroutine M:N模型 go创建M个线程，之后创建个N个goroutine会依附在M个线程上执行。 pstree 命令看进程下几个线程 同一时刻，一个线程只能跑一个goroutine，当goroutine发生阻塞（chan阻塞，mutex，syscall陷入内核）时，go的runtime会进行调度，让其他g</description>
    </item>
    
    <item>
      <title>虚拟内存</title>
      <link>https://nepp-an.github.io/post/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Thu, 08 Jul 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>mmap： 在进程的虚拟内存地址空间中分配地址，创建和物理内存之间的映射关系。mmap在虚拟内存中分配空间，只有在第一次使用虚拟内存的时候才分配物理内存。 mmap的write： 1. 用户态将需要写入的数据直接拷贝到mmap的地址 2. 若mmap地址未对应物理地址，缺页异常，由内核处理 3. 若对</description>
    </item>
    
    <item>
      <title>Ledis_db</title>
      <link>https://nepp-an.github.io/post/Ledis_db/</link>
      <pubDate>Mon, 31 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/Ledis_db/</guid>
      <description>LSM-Tree Log Structured-Merge Tree，在面对亿级别之上的海量数据的存储和检索的场景下，我们选择的数据库通常都是各种强力的NoSQL，比如Hbase，Cassandra，Leveldb，RocksDB等等，这其中前两者是Apache下面的顶级开源项目数据库，后两者分别是Google和Facebook开源</description>
    </item>
    
    <item>
      <title>golang worker pool 协程池</title>
      <link>https://nepp-an.github.io/post/golang_worker-_pool/</link>
      <pubDate>Tue, 25 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang_worker-_pool/</guid>
      <description>协程池 golang语言原生的goroutine和channel等机制，对于并发编程提供了很简单的实现。一个go关键字即可生成一个独立的协程。协程的管理需要协程池去实现。 对worker的总协程数量进行限制 限制并发 有任务排队时也不阻塞任务的提交 数据结构 1 2 3 4 5 6 7 8 9 10 11 12 type TaskHandler func() error</description>
    </item>
    
    <item>
      <title>golang网络轮询器</title>
      <link>https://nepp-an.github.io/post/golang%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/</link>
      <pubDate>Sat, 15 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E7%BD%91%E7%BB%9C%E8%BD%AE%E8%AF%A2%E5%99%A8/</guid>
      <description>网络轮询器 大部分服务都是I/O密集型的，程序会花费大量时间等待I/O操作的完成。网络轮询器是golang runtime用来处理I/O操作的关键部件，它使用了操作系统提供的I/O多路复用机制增强并发能力。 设计原理 网络轮询器不仅用于监控网络I/O，还用于监控文件I/O。 I/O模型 操作</description>
    </item>
    
    <item>
      <title>golang调度器</title>
      <link>https://nepp-an.github.io/post/golang%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Fri, 14 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description>调度器 golang语言强大的并发编程能力，得益于语言在原生层面对并发的支持。接下来介绍go语言运行时调度器的设计和实现，以及运行调度相关的数据结构。 进程与线程 process/thread 多个线程可以同属于一个进程，并共享内存空间。线程之间的通信就是通过基于共享的内存进行的，与重量的进程相比，线程更轻。但是</description>
    </item>
    
    <item>
      <title>播放历史架构设计</title>
      <link>https://nepp-an.github.io/post/%E6%92%AD%E6%94%BE%E5%8E%86%E5%8F%B2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 13 May 2021 11:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E6%92%AD%E6%94%BE%E5%8E%86%E5%8F%B2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>评论系统架构设计</title>
      <link>https://nepp-an.github.io/post/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 07 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</guid>
      <description>架构设计 架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象，不要做需求的翻译机。评论系统，需要做成评论平台，可以接入各种业务形态。 需要实现以下几个功能： 发布评论：支持回复楼层 读取评论：按照时间、热度排序 删除评论：用户和up主可以删除</description>
    </item>
    
    <item>
      <title>经典排序算法</title>
      <link>https://nepp-an.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 03 May 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>排序算法分析 排序是指将一组对象根据一定的逻辑进行重新排列的过程。排序的算法应用于计算机的各个领域中，排序的快慢对社会运转起着至关重要的作用。 常见的基础排序算法有：冒泡排序、选择排序、插入排序、希尔排序等，这些排序算法的时间复杂度较高，仅适用于小规模数据的排序。 针对于大规模数据，常</description>
    </item>
    
    <item>
      <title>leetcode_pattern</title>
      <link>https://nepp-an.github.io/post/leetcode_pattern/</link>
      <pubDate>Fri, 19 Feb 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/leetcode_pattern/</guid>
      <description>算法题的几种模式 滑动窗口 滑动窗口用于在给定数组或者链表的特定窗口大小上执行所需的操作，比如查找最长的子字符串或者子数组。 题目 1004. 最大连续1的个数 III 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。返回仅包含 1 的最长（连续）子数组的长度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
    </item>
    
    <item>
      <title>golang相关</title>
      <link>https://nepp-an.github.io/post/go_%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 15 Feb 2021 10:49:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/go_%E4%BD%BF%E7%94%A8/</guid>
      <description>go test 介绍 https://geektutu.com/post/quick-go-test.html https://pkg.go.dev/testing go modules 依赖管理 https://blog.golang.org/using-go-modules</description>
    </item>
    
    <item>
      <title>geektime golang课程总结</title>
      <link>https://nepp-an.github.io/post/golang%E8%BF%9B%E9%98%B6summary/</link>
      <pubDate>Sun, 14 Feb 2021 10:49:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E8%BF%9B%E9%98%B6summary/</guid>
      <description>微服务概览与治理 go语言实践 - error go语言实践 - concurrency go工程化实践 微服务可用性设计 评论系统架构设计 播放历史架构设计 分布式缓存&amp;amp;分布式事务 go语言实践 - 网络编程 日志&amp;amp;指标&amp;amp;链路追踪 DNS&amp;amp;CDN&amp;amp;多活架构</description>
    </item>
    
    <item>
      <title>distributed locks</title>
      <link>https://nepp-an.github.io/post/distributed_lock/</link>
      <pubDate>Thu, 14 Jan 2021 11:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/distributed_lock/</guid>
      <description>分布式锁 redis 实现 加锁:SETNX key value，当 key不存在时将 key的值设为 value ，返回值为 1；若给定的 key 已经存在，则 SETNX不做任何动作，返回值为 0 。 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证</description>
    </item>
    
    <item>
      <title>2021 schedule</title>
      <link>https://nepp-an.github.io/post/2021/</link>
      <pubDate>Sun, 10 Jan 2021 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/2021/</guid>
      <description>2021年的N个问题 通过问题的形式完成2021年的技术领域的学习计划，每个部分最少包含5个问题，问题总数在50个左右 数据结构与算法 决策树是什么 深度优先遍历 广度优先遍历 设计模式 分布式的AP CP CAP什么意思 缓存和数据库 redis的sentinel机制 哨兵 中间件 kafka CDN 分布式锁的实现 redis 编程</description>
    </item>
    
    <item>
      <title>stock</title>
      <link>https://nepp-an.github.io/post/stock/</link>
      <pubDate>Sat, 05 Dec 2020 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/stock/</guid>
      <description>基本原则 闲钱投资 不动用大资产 经历完整牛熊过的人才是有经验的 提高胜率才是最主要的 关键要素 趋势投资，以月或者周为周期，建立分析系统 买卖策略，来行情该买什么 投资纪律和经验，怎样持续盈利 分析和判断市场 把影响市场的因素明确 政策：货币，财政 技术图：K线图，关注资金量 市场情绪：很难量化 资金变化</description>
    </item>
    
    <item>
      <title>sync_Pool_golang</title>
      <link>https://nepp-an.github.io/post/sync.Pool_golang/</link>
      <pubDate>Sat, 05 Dec 2020 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/sync.Pool_golang/</guid>
      <description>syn.Pool leak.Pool io.Writer在使用sync.Pool之后，延迟变高 golang bufio的用法</description>
    </item>
    
    <item>
      <title>golang中的坑</title>
      <link>https://nepp-an.github.io/post/golang%E5%9D%91/</link>
      <pubDate>Sat, 07 Nov 2020 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E5%9D%91/</guid>
      <description>slice 1 2 3 4 // a[low : high : max] path := []byte(&amp;#34;AAAA/BBBBBBBBB&amp;#34;) sepIndex := bytes.IndexByte(path,&amp;#39;/&amp;#39;) dir1 := path[:sepIndex:sepIndex] //Full slice expression, last index is capacity append golang的append不是值拷贝，特别是在append函数入参的时候，尽量使用copy函数先处理一下再append，否则会踩很多坑。 slice的核心内容有两点： 函数为值复制传递 slice的属性包含指向底层数组的指针、ca</description>
    </item>
    
    <item>
      <title>蚂蚁金服</title>
      <link>https://nepp-an.github.io/post/ant_group/</link>
      <pubDate>Sat, 07 Nov 2020 11:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/ant_group/</guid>
      <description>2020-11-03 中国银保监会 中国人民银行关于《网络小额贷款业务管理暂行办法（征求意见稿）》公开征求意见的公告。 正在公开征求意见，截止时间为2020年12月2日。 小额贷款公司经营网络小额贷款应当主要在注册地所属省级行政区域内开展；未经国务院银行业监督管理机构批准，小额贷款公司不得跨省级行政区域开</description>
    </item>
    
    <item>
      <title>2020年11月股市展望</title>
      <link>https://nepp-an.github.io/post/November-Strategy/</link>
      <pubDate>Sun, 01 Nov 2020 09:50:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/November-Strategy/</guid>
      <description>11月各路财经大V意见整理 11月有几件大事 蚂蚁金服上市 美国大选 月底机构业绩排名，年度结账 蚂蚁上市会影响当天的流动性，只会对当天形成影响。 美国大选会影响美股的短期走势，从而影响A股。 月底机构结账这个是影响最大的，前期大批白马股跌停已经提前反映了。 11月的整体策略还是控制仓位，不超过</description>
    </item>
    
    <item>
      <title>Haystack 图片存储系统</title>
      <link>https://nepp-an.github.io/post/haystack/</link>
      <pubDate>Fri, 30 Oct 2020 14:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/haystack/</guid>
      <description>主要核心是减少硬盘操作 After reducing directory sizes to hundreds of images per directory, the resulting system would still generally incur 3 disk operations to fetch an image: one to read the directory metadata into memory, a second to load the inode into memory, and a third to read the file contents.</description>
    </item>
    
    <item>
      <title>lru的实现</title>
      <link>https://nepp-an.github.io/post/lru/</link>
      <pubDate>Thu, 29 Oct 2020 15:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/lru/</guid>
      <description>本地缓存常常使用LRU进行更新 LRU的go版本实现，借助了go自带的list类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 type Key interface{} type</description>
    </item>
    
    <item>
      <title>6.824课程</title>
      <link>https://nepp-an.github.io/post/1025/</link>
      <pubDate>Sun, 25 Oct 2020 21:12:44 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/1025/</guid>
      <description>6.824 mapReduce raft :horse:</description>
    </item>
    
    <item>
      <title>收益率为啥越来越低呢</title>
      <link>https://nepp-an.github.io/post/ROA_20201024/</link>
      <pubDate>Sat, 24 Oct 2020 22:15:47 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/ROA_20201024/</guid>
      <description>十年期国债可以说是无风险收益率标杆，普通民众买到的几率比较低。 对老百姓来说，银行定期存款就是无风险收益率。2020年的3年定期不到4%。 理财产品最近工行的4%收益率都暴雷违约了，银行会兜底。 202010月中国国债收益率3.19% 202010月美国国债收益率0.83% 无风险收益率提</description>
    </item>
    
    <item>
      <title>My First Blog</title>
      <link>https://nepp-an.github.io/post/my-first-blog/</link>
      <pubDate>Sat, 24 Oct 2020 16:53:46 +0800</pubDate>
      
      <guid>https://nepp-an.github.io/post/my-first-blog/</guid>
      <description>Hello World!!! </description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/golang%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/signal&amp;#34; &amp;#34;syscall&amp;#34; &amp;#34;time&amp;#34; ) type Result struct { Hit string Err error } //// Search runs query on a backend and returns the result. //type Search func(query string) Result  // //// First runs query on replicas and returns the first result. //func First(query string, replicas ...Search) Result { // c := make(chan Result, len(replicas)) // search := func(replica Search) { c &amp;lt;- replica(query) } // for _, replica := range replicas { // go search(replica) // } // return &amp;lt;-c //}  // Search runs query on a backend and returns the result.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/grpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/grpc/</guid>
      <description>gRPC是Google开源的RPC框架，具有以下的优点：
 提供高效的进程间通信。gRPC没有使用XML或者Json的文本格式，而是采用基于protocol buffers的二进制协议；同时使用HTTP/2作为通信协议，从而能快速的处理进程间通信。 简单且良好的服务接口和模式。契约优先，先定义接口，再实现细节。 支持多语言  再介绍下RPC： RPC：Remote Procedure Call 远程过程调用，简单的理解是一个节点请求另一个节点的服务。与远程过程调用相对的就是本地过程调用，通过函数指针进行实现。那远程过程调用如何通知远程机器要调用这个方法呢？
// Client端 // Student student = Call(ServerAddr, addAge, student) 1. 将这个调用映射为Call ID。 2. 将Call ID，student（params）序列化，以二进制形式打包 3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层 4. 等待服务器返回结果 5. 如果服务器调用成功，那么就将结果反序列化，并赋给student，年龄更新 // Server端 1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用Map&amp;lt;String, Method&amp;gt; callIdMap 2. 等待客户端请求 3. 得到一个请求后，将其数据包反序列化，得到Call ID 4. 通过在callIdMap中查找，得到相应的函数指针 5. 将student（params）反序列化后，在本地调用addAge()函数，得到结果 6. 将student结果序列化后通过网络返回给Client gRPC包含四种基础的通信模式：
 一元模式 服务器端流RPC 客户端流RPC 双向流RPC  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/linux/</guid>
      <description>linux 查问题 yum install nmon top pref top us: user cpu time (or) % CPU time spent in user space sy: system cpu time (or) % CPU time spent in kernel space ni: user nice cpu time (or) % CPU time spent on low priority processes id: idle cpu time (or) % CPU time spent idle wa: io wait cpu time (or) % CPU time spent in wait (on disk) hi: hardware irq (or) % CPU time spent servicing/handling hardware interrupts si: software irq (or) % CPU time spent servicing/handling software interrupts st: steal time - - % CPU time in involuntary wait by virtual cpu while hypervisor is servicing another processor (or) % CPU time stolen from a virtual machine si不均衡：网卡多队列/ DPDK</description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/Mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/Mysql/</guid>
      <description>title: &amp;ldquo;mysql相关&amp;rdquo; date: 2021-07-11T09:50:44+08:00 draft: false</description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/redis%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/redis%E5%AE%9E%E7%8E%B0/</guid>
      <description>SDS动态字符串 1 2 3 4 5  struct sdshdr { int len; int free; char buf[]; }   Char buf[]最后一个字节保存空字符&amp;rsquo;\0&amp;rsquo;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>title: &amp;ldquo;UNIX环境高级编程&amp;rdquo; date: 2021-05-03T21:12:44+08:00 draft: false categories: [&amp;ldquo;数据结构与算法&amp;rdquo;] tags: [&amp;ldquo;数据结构与算法&amp;rdquo;]
第15章 进程间通信 ![image-20210512113039490](/Users/anpuqiang/Library/Application Support/typora-user-images/image-20210512113039490.png)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/%E9%9C%80%E6%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E9%9C%80%E6%B1%82/</guid>
      <description>Ai push scheduler分时区发送增加俄罗斯  在us-en基础上增加ru-ru 本地落盘缓存延迟发送的token  原有实现将延迟发送的token和延迟时间保存在内存中sleep 程序重启后内存中数据会丢失，增加落盘    落盘实现  分文件保存，文件名称country_language_send_time(send_time加个随机，防止重复) delayWriteAIMsgsToKafka中函数开始写文件，若成功发送后删除缓存文件 缓存文件内格式- json 重启后，获取local-time， 遍历缓存文件，计算sleep-time  图片服务   错误图片替换
 复用upload页面 后台增加cdn删除接口的调用    搜索近似图的过程展示
​
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://nepp-an.github.io/post/%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://nepp-an.github.io/post/%E9%9D%A2%E8%AF%95/</guid>
      <description>title: &amp;ldquo;面试&amp;rdquo; date: 2021-05-03T21:12:44+08:00 draft: false categories: [&amp;ldquo;面试&amp;rdquo;] tags: [&amp;ldquo;面试&amp;rdquo;]
  自我介绍
   考察表达能力，面试准备情况 5    校内情况讨论
    项目、竞赛、论文方面
   硕士期间研究方向    考察对计算机的学习热情、自主学习能力 4
    计算机基础
    基于简历，从操作系统、网络、编译原理和体系结构里出2-3个问题
    进程
  操作系统运行程序大概流程
   必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。 堆/栈区别    线程 共享地址空间
  字节序 数据在内存中的存储顺序 大端/小端
  tcp/udp 传输层区别
  tcp三次握手/四次挥手
  I/O多路复用，select poll epoll
    考察专业基础是否扎实
   grpc      语言基础
    c/c++为主
   HashMap底层结构 哈希表和红黑树 vector 和数组区别 volatile cpu多级缓存和内存屏障 memcpy和strcpy的差别 函数重载    结合编译和运行时
   内存对齐的原理与意义 内存泄露 https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html      代码题目
   排序算法，归并排序，快排 二叉树层次遍历，z型打印 LRU/堆 判断链表环 判断是否为二叉搜索树 二叉树中序遍历 根据前序遍历，中序遍历结果还原二叉树 判断平衡二叉树 求二叉树深度    /**</description>
    </item>
    
  </channel>
</rss>